#!/bin/bash
# Name:	 lrcdis （外挂式显歌词脚本）
# License:  GPLv3
# Credit:   xiooli,solcomo,bones7456,oldherl  (2008-2009)
# Encoding: UTF-8
# Thanks to: 搜狗歌词搜索

Version=svn-090320
#是否开启调试信息
Debug=0
Conf_file=~/.config/lrcdis.conf

#=========================定义函数=============================

INIT() {
	#程序初始化函数

	#没有参数，正确执行如果没有配置文件则会产生配置文件并加载配置，有配置文件则加载配置文件

	[ -f "$Conf_file" ] || cat<< EOF > "$Conf_file"
#===================LRCDIS-CONFIG================
#保存lrc文件的文件夹
Lrcdir=~/.lyrics
#显示模式： cli, osd, notify, fifo (将歌词输出到一个管道文件，以便用其他命令访问)
Dismode=osd
#播放器类型： mpd, mocp, audacious, juk, amarok, exaile, quodlibet, rhythmbox
Player=rhythmbox
#获取歌曲名称方式： id3 id3标签方式， filename 文件名方式
Readname=id3
#自身时间发生器产生时间的间隔（最好小于1秒）
Sleeptm=0.6
#======================[cli]=====================
#命令行显示时的参数
#一屏显示行数
Row=10
#歌曲标题的颜色（见最后的颜色定义）
Titlecolor=\$green
#歌曲歌词的颜色（见最后的颜色定义）
Lyricscolor=\$smoothblue
#=================[osd && notify]================
#osd显示时的参数
#osd显示位置：top, bottom
Vposition=top
#osd对齐位置：left, right, center
Halignment=center
#osd最长显示时间（超过则隐藏,单位毫秒？）
Timeout=10000
#span size
Size=20000
#字体颜色： green, white, blue, yellow, grey...
#注意，这个颜色与cli模式的颜色不是一回事
Foreground=green
#动画效果： off, on
Animations=off
#是否加新行，以免挡住panel等: off, on
Addnewline=off
#notify模式的图标文件名(只支持绝对路径)
NotifyIcon=""
#================================================
#定义颜色（仅在cli模式下使用）
black="38;5;0m"
red="38;5;1m"
green="38;5;2m"
yellow="38;5;3m"
blue="38;5;4m"
magenta="38;5;55m"
cyan="38;5;6m"
white="37;5;0m"
coldblue="38;5;33m"
smoothblue="38;5;111m"
iceblue="38;5;45m"
turqoise="38;5;50m"
smoothgreen="38;5;42m"
#======================END========================
EOF

	. "$Conf_file" #在这里如果source一次的话颜色代码不会工作，大家看看怎么改。（source两次太恶了）-- xiooli
	# how about save color codes into another file named "lrcdis.colors"
	#sorry for not typing Chinese because of editor's bug   --oldherl
	. "$Conf_file"
}

DO_NAME() {
	#  1 argument, the filename

	#  removing .mp3/.wma/.ogg etc.
	local a
	a="`basename "$1"`"
	a="${a/%.mp3/}"; a="${a/%.MP3/}"
	a="${a/%.wma/}"; a="${a/%.WMA/}"
	a="${a/%.ogg/}"; a="${a/%.OGG/}"
	echo "$a"
}

USAGE() {
	#显示帮助信息的函数

	#没有参数，执行显示帮助信息

	cat << EOF
lrcdis $Version (http://code.google.com/p/lrcdis)
用法： $0 [选项]
选项：

	-C <Config file name>
		specify config file name (default: ~/.config/lrcdis.conf)
	-s <Save directory>
		specify directory to save lyrics (default: ~/.lyrics)
	-d <歌曲名>
		仅下载歌词, 保存至歌词目录
	-p <Player>
		Try that player first. Will search for others if not present.
	-m <Dismode>
		Display in that mode. (See following)
	-m osd
		以osd模式显示歌词(needs gnome-osd)
	-m notify
		以notify模式显示歌词(needs notify-send)
	-m fifo
		将歌词输出到管道文件/dev/shm/lrcfifo
	-m title
		将歌词输出到终端的标题中(支持大多数终端)
	-m echo
		将歌词以普通echo模式输出
	-m cli
		以cli模式显示歌词
	-D
		Debug mode
	-h
		显示本帮助信息并退出
	-v
		显示版本号并退出
备注：不加任何选项则以 $Conf_file 为配置文件初始化运行
EOF
}

PLAYER_USERS() {

	#一个参数,播放器进程名,返回该进程可能对应的用户ID.
	id -u | tr -d "\n"
	if [ "$1" = "mpd" ];then
		echo -n ",0" #mpd以root运行算合法
		if id -u mpd >/dev/null 2>&1 ;then
			echo -n ","
			id -u mpd | tr -d "\n" #mpd以mpd用户运行算合法
		fi
	fi
}

PLAYER_RUNNING(){
	#判断播放器进程是否存在

	#一个参数, 播放器名
	{
	if [ "$1" = "quodlibet" ]; then
		pgrep -fx "python `which quodlibet`" -u `PLAYER_USERS "$1"`
	else
		pgrep -x "$1" -u `PLAYER_USERS "$1"`
	fi
	} >/dev/null
}

CHECK_PLAYER() {
	#自动检查播放器类型的函数

	#没有参数，返回播放器类型
	
	local players i

	#所有被支持的播放器都保存下面的字符串里面
	players="rhythmbox audacious juk amarok amarokapp exaile quodlibet mocp mpd mplayer"
	if PLAYER_RUNNING "$Player";then
		echo -n "$Player"
	else
		for i in $players;do
			[ "$Debug" = 1 ] && echo "$Player   $i" >&2
			if PLAYER_RUNNING "$i";then
				echo -n "$i"|sed "s/quodli/quodlibet/;s/amarokapp/amarok/"
				break
			fi
		done
	fi
}

BAIDU_URI(){
	#得到百度歌词文件的下载URL

	# 1 argument: gb
	local htm
	htm="`wget "http://mp3.baidu.com/m?f=ms&tn=baidump3lyric&ct=150994944&lf=2&rn=10&word="$1"&lm=-1" -q -T 10 -O- 2>/dev/null`"
	echo "$htm" | grep -F .lrc | cut -d' ' -f3 | cut '-d"' -f2 | head -n 1
}
SOGOU_URI(){
	#得到搜狗歌词文件的下载URL

	# 1 argument: gb
	local htm a
	htm="`wget "http://mp3.sogou.com/gecisearch.so?query="$1"" -q -T 10 -O- 2>/dev/null | iconv -f gbk`"
	#[ "$Debug" = 1 ] && echo "HTM $htm" > /tmp/htm
	a="`echo "$htm" | grep -Fim1 "downlrc"|awk -F\\\" '{print $2}'`"
	[ "$Debug" = 1 ] && echo "A $a" >&2
	[ "$a" = "" ]|| echo -n 'http://mp3.sogou.com/'"$a"
}

DOWNLRC(){
	#下载歌词的函数

	#参数一个，$1 (str)： 歌曲名字; 没有返回值，正确执行会下载一个 lrc 文件至 Lrcdir

	local nm link full_link gb file

	nm="$1"
	[ ! -d "$Lrcdir" ] && mkdir -p "$Lrcdir"
	file="$Lrcdir/$nm.lrc"
	
	#将歌曲名字转换为urlencode，utf-8的locale必须先转换为gbk的编码
  	gb="$(echo -n "$nm" | iconv -c -t gbk | od -t x1 -A n -w1000|tr " " "%")"

	#从baidu搜索里面找出当前歌曲的歌词下载页
	#FIXME: just for a try
  	link="`SOGOU_URI "$gb"`"
	[ "$Debug" = 1 ] && echo "Link: $link" >&2
  	while [ "$link" ] && [ ! -s "$file" ];do
		wget "$link" -T 5 -t 2 -q -O -|iconv -f gbk -c | tr -d "\r" > "$file"
		{ echo '<xml>'; cat "$file"; echo '</xml>';} > /tmp/lrcdisTMP.xml
		xmllint /tmp/lrcdisTMP.xml --encode UTF-8 2>/dev/null > /tmp/lrcdisTMP.lrc && {
			cat /tmp/lrcdisTMP.lrc | head -n -1 | tail -n +3 > "$file"
		}
		rm /tmp/lrcdisTMP* &>/dev/null
	done
}

GET_TITLE() {
	#获取当前播放的歌曲名字

	#参数两个，$1 播放器类型,默认 rhythmbox、$2 获取歌曲名字方式，默认取id3; 返回正在播放的歌曲名
	#请大家最好不要使用'"'这样的东西，而是用\"来代替，这样大多数编辑器高亮都能认识…… --oldherl
	#title和artist信息应该尽量同时获取(而不是使用两个命令分别获取)
	#以免此时播放器进入下一首而造成错位 (A的标题和B的歌手名)，参见mocp, quodlibet的处理方法
	local readname t a tmp flag ans sn

	readname=${2:-id3}

	case "${1:-rhythmbox}" in
	"mpd")
	flag="LRCDISXXX"
	if [ "$readname" = "filename" ] ; then
		  sn="`mpc --format "$flag%file%" | grep "$flag" `"
		  ans="${sn/$flag/}"
	else  
		  sn="`mpc --format "[$flag[%artist% - ]%title%]|$flag[%file%]" | grep "$flag" `"
		  ans="${sn/$flag/}"
	fi  
	ans="`DO_NAME "$ans"`"
	echo "$ans"
	[ "$Debug" = 1 ]&& echo "GET_TITLE: $ans" >&2
	;;
	"mocp")
		tmp="`mocp -i`"
		if [ "$readname" = "filename" ];then
			DO_NAME "`echo "$tmp" | grep "^File: " | cut -d\  -f2- `"
		else
			t="`echo "$tmp" |grep "^SongTitle: "| cut -d\  -f2- `"
			a="`echo "$tmp" |grep "^Artist: "| cut -d\  -f2- `"
			if [ "$t" ];then
				[ "$a" ] && echo -n "$a - "
				echo "$t"
			else
				DO_NAME "`echo "$tmp" | grep "^File: " | cut -d\  -f2- `"
			fi
		fi
	;;
	"audacious")
		if [ "$readname" = "filename" ];then
			f="`audtool current-song-filename`"
			echo "`DO_NAME "$f"`"
		else
			t="`audtool current-song`"
			if [ "$t" ];then
				echo "$t"
			else
				f="`audtool current-song-filename`"
				echo "`DO_NAME "$f"`"
			fi
		fi
	;;
	"juk")
		if [ "$readname" = "filename" ];then

			#TODO (dont know how to get title & artist using dbus-send, use qdbus instead temporarily)
			#f="`dbus-send --print-reply --dest=org.kde.juk /Player org.kde.juk.player.playingString \
			#|grep 'string'|awk -F\" '{print $2}'`"
 			f="`qdbus org.kde.juk /Player trackProperty Path`"
 			echo "`DO_NAME "$f"`"
 		else
 			t="`qdbus org.kde.juk /Player trackProperty Title`"
 			if [ "$t" ];then
 				echo "$t"
 			else
 				f="`qdbus org.kde.juk /Player trackProperty Path`"
 				echo "`DO_NAME "$f"`"
 			fi
 		fi
 	;;
	"amarok")
		if [ "`amarok -v|grep "Amarok:\ *2\.*"`" ];then
			tmp="`dbus-send --session --print-reply --dest=org.kde.amarok /Player org.freedesktop.MediaPlayer.GetMetadata`"
			if [ "$readname" = "filename" ];then
				f="`echo "$tmp" |grep 'string "file:'|perl -p -e 's/%(..)/pack("c", hex($1))/eg'|sed 's/^.*\///'`"
				echo "`DO_NAME "$f"`"	
			else
				#下面的awk如果用-F\"则会出现：unexpected EOF while looking for matching `"' --xiooli
				t="`echo "$tmp" |grep -FA1 'string "title"'|tail -n1|awk -F'"' '{print $2}'`"
				a="`echo "$tmp" |grep -FA1 'string "artist"'|tail -n1|awk -F'"' '{print $2}'`"
				if [ "$t" ];then
					[ "$a" ] && echo -n "$a - "
					echo "$t"
				fi
			fi
		else
			#TODO amarok1不能读取id3信息？
			#amarok1我没有，不能测试。--xiooli
			DO_NAME "`dcop amarok player nowPlaying`"
		fi
	;;
	"exaile")
		t="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.get_title \
			| sed -n '$p'|awk -F\" '{print $2}'`"
		tmp="`DO_NAME "$t"`"
		if [ "$tmp" != "$t" ] ; then
			echo "$tmp"
		else
			a="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.get_artist \
			| sed -n '$p'|awk -F\" '{print $2}'`"
			[ "$a" ] && echo -n "$a - "
			echo "$t"
		fi
	;;
	"quodlibet")
		tmp="`dbus-send --session --print-reply --dest=net.sacredchao.QuodLibet /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.CurrentSong`"
		#下面的tab符是需要的，不能去掉
		a="`echo "$tmp" | grep -FA1 '	string "artist"' | tail -n 1 | awk '-F[\"\"]' '{print $2}'`"
		t="`echo "$tmp" | grep -FA1 '	string "title"' | tail -n 1 | awk '-F[\"\"]' '{print $2}'`"
		echo "$a" - "$t"
	;;
	"rhythmbox")
		t="`rhythmbox-client --print-playing --no-start 2>/dev/null|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA|未播放/,"",$0);print $0 }'`"
		#播放器还未播放的时候会返回空,不应该exit
		#[ "$t" ] || exit
		echo "$t"
	;;
	"mplayer")
		[ -p "/dev/shm/mfifo" -a -p "/dev/shm/ififo" -a "`ps ax|grep "mplayer"|grep "/dev/shm/mfifo"`" ] || exit
		echo "get_file_name">/dev/shm/mfifo
		t="`cat "/dev/shm/ififo"|awk -F\' '/^ANS_FILENAME/{gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$2);print $2}'`"
		[ "$t" ] && echo "$t"
	;;
	esac
}   

GET_PLTM() {
   #参数一个，$1，播放器类型；返回播放器播放歌曲的当前时间 (转换成秒)

   #GET_PLTM如果是空那么就表示已经停止或者播放器退出。
   #请大家最好不要使用'"'这样的东西，而是用\"来代替，这样大多数编辑器高亮都能认识…… --oldherl
   
	local tm min sec tmptm

	case "${1:-rhythmbox}" in
	"mpd")
		tm="`mpc --format a | grep "/" | awk -F' ' '{print $3}' | awk -F'/' '{print $1}'`"
		[ "$Debug" = 1 ] && echo "GET_PLTM: ${tm}<<" >&2
		[ -n "$tm" ] && {
			min=${tm//:*/}
			tmptm=${tm//*:/}
			sec=${tmptm/#0/}
			echo "$(($min*60+$sec))"
		}
	;;
	"mocp")
		tm="`mocp -i | grep "^State: " | tail -c 2 `"
		# Y means PLAY...
		[ "$tm" = "Y" ] && {
			tm="`mocp -i | grep "^CurrentSec: " | cut -d\  -f2- `"
			[ "$tm" ] && echo $(($tm))
		}
	;;
	"audacious")
		tm="`audtool current-song-output-length-seconds`"
		[ "$tm" ] && echo "$tm"
	;;
	"juk")
		tm="`dbus-send --print-reply --dest=org.kde.juk /Player org.kde.juk.player.currentTime \
		|grep 'int32'|awk '{print $2}'`"
		[ "$tm" ] && echo "$tm"
	;;
	"amarok")
		if [ "`amarok -v|grep "Amarok:\ *2\.*"`" ];then
			tm="`dbus-send --session --print-reply --dest=org.kde.amarok /Player org.freedesktop.MediaPlayer.PositionGet \
			|grep int32|awk '{print $2}'`"
			tm=$(($tm/1000))
		else
			tm="`dcop amarok player trackCurrentTime`"
		fi
			[ "$tm" ] && echo "$tm"
	;;
	"exaile")
		tm="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.query \
		|tail -c 10 |awk -F[][] '{print $2}'`"
		min=${tm//:*/}
		tmptm=${tm//*:/}
		sec=${tmptm/#0/}
		[ "$tm" ] && echo $(($min*60+$sec))
	;;
	"quodlibet")
		tm="`dbus-send --session --print-reply --dest=net.sacredchao.QuodLibet /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.GetPosition \
		|sed -n '$p'|awk '{print $2}'`"
		[ "$tm" ] && echo $(($tm/1000))
	;;
	"rhythmbox")
		tm="`dbus-send --session --print-reply --dest=org.gnome.Rhythmbox /org/gnome/Rhythmbox/Player org.gnome.Rhythmbox.Player.getElapsed 2>/dev/null \
		|tail -n 1|awk '{print $2}'`"
		[ "$tm" ] && echo "$tm"
	;;
	"mplayer")
		[ -p "/dev/shm/mfifo" -a -p "/dev/shm/ififo" -a "`ps ax|grep "mplayer"|grep "/dev/shm/mfifo"`" ] || exit
		echo "get_time_pos">/dev/shm/mfifo
		tm="`cat "/dev/shm/ififo"|sed 's/^.*=//;s/\..*$//'`"
		[ "${tm//-/}" = "$tm" -a "$tm" != "0" ] && echo "$tm"
	;;
	esac

}

GET_LEN() {
   #参数一个，$1，播放器类型；返回播放器当前播放歌曲的总时间 (转换成秒)

   # not used in the program since it's not done...  --oldherl
   #请大家最好不要使用'"'这样的东西，而是用\"来代替，这样大多数编辑器高亮都能认识…… --oldherl
   
	local tm min sec tmptm

	case "${1:-rhythmbox}" in
	"mpd")
		tm="`mpc --format "%time%" | head -n -2`"
		[ "$Debug" = 1 ] && echo "GET_LEN: ${tm}<<" >&2
		[ -n "$tm" ] && {
			min=${tm//:*/}
			tmptm=${tm//*:/}
			sec=${tmptm/#0/}
			echo "$(($min*60+$sec))"
		}
	;;
	"mocp")
		tm="`mocp -i | grep "^TotalSec: " | sed -e 's/TotalSec:\ //'`"
		[ "$tm" ] && echo $tm
	;;
	"audacious")
		tm="`audtool current-song-length-seconds`"
		[ "$tm" ] && echo "$tm"
	;;
	"juk")
		tm="`dbus-send --print-reply --dest=org.kde.juk /Player org.kde.juk.player.totalTime \
		|grep 'int32'|awk '{print $2}'`"
		[ "$tm" ] && echo "$tm"
	;;
	"amarok")
		tm="`dbus-send --session --print-reply --dest=org.kde.amarok /Player org.freedesktop.MediaPlayer.GetMetadata \
		|grep -FA1 'string "mtime"'|tail -n1|awk '{print $3}'`"
		[ "$tm" ] && echo $(($tm/1000))
	;;
	"exaile")
		tm="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.get_length \
		| tail -n 1 |awk -F\" '{print $2}'`"
		min=${tm//:*/}
		tmptm=${tm//*:/}
		sec=${tmptm/#0/}
		[ "$tm" ] && echo $(($min*60+$sec))
	;;
	"quodlibet")
		tm="`dbus-send --session --print-reply --dest=net.sacredchao.QuodLibet /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.CurrentSong \
		|grep -FA1 string\ \"~#length\" | tail -n 1 | cut -d\" -f2 `"
		[ "$tm" ] && echo "$tm"
	;;
	"rhythmbox")
		#TODO
	;;
	"mplayer")
		[ -p "/dev/shm/mfifo" -a -p "/dev/shm/ififo" -a "`ps ax|grep "mplayer"|grep "/dev/shm/mfifo"`" ] || exit
		echo "get_time_length">/dev/shm/mfifo
		tm="`cat "/dev/shm/ififo"|sed 's/ANS_LENGTH=//;s/\..*$//'`"
		[ "$tm" ] && echo "$tm"
	;;
	esac

}

DIS_WORDS() {
	#以各种预设的模式显示文字

	#两个参数; $1:T标题W普通歌词E错误信息  正确执行按照Dismode将 $2 格式化输出

	local line i j nl

	line="$2"
	nl="\n "
	#[ "$2" = "" ] && exit

	if [ "$Dismode" = "osd" -a "`which gnome-osd-client 2>/dev/null`" ];then
		line="`echo "$line" | sed "s/&/\&amp;/g" | sed "s/</\&lt;/g" | sed "s/>/\&gt;/g"`"
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		if [ "$Addnewline" = "on" ];then
			if [ "$Vposition" = "top" ];then
				line="$nl$line"
			else
				line="$line$nl"
			fi
		fi
		#NOTE: 下面的echo是需要的，不然\n会直接显示出来。
		gnome-osd-client -f "<message id='lrcdis' osd_fake_translucent_bg='off' osd_vposition='$Vposition' osd_halignment='$Halignment' animations='$Animations' hide_timeout='$Timeout'><span size='$Size' foreground='$Foreground'>`echo -ne "$line"`</span></message>"
	elif [ "$Dismode" = "fifo" -a -p "/dev/shm/lrcfifo" ];then
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		#cat < /dev/shm/lrcfifo & # there's no need to empty the fifo file anymore.
		echo -ne "$line" > /dev/shm/lrcfifo
	elif [ "$Dismode" = "notify" -a "`which notify-send 2>/dev/null`" ];then
		[ "$2" = "" ] && return
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		if [ -n "$NotifyIcon" ];then
			notify-send -c lrcdis -i "$NotifyIcon" -t "$Timeout" -- "$line"
		else
			notify-send -c lrcdis -t "$Timeout" -- "$line"
		fi
	elif [ "$Dismode" = "title" ];then
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		echo -ne "\e]0;$line\a"
	elif [ "$Dismode" = "cli" ];then
		if [ "$1" = W ] ;then
			N="${N:-1}"
			[ "$N" = "1" ] && \
			for i in `seq $Row`;do
				tput cup "$i" 0
				echo -ne "\e[K"
			done
			tput cup "$N" 0
			echo -ne "\033[0;$Lyricscolor "${line/#]/}" \033[0m"
			if [ "$N" -lt "$Row" ];then
				((N="$N"+1))
			else
				((N=1))
			fi
		else
			if [ "$1" = T ] ;then
				line="****** $line ******"
			else
				line="错误: $line"
			fi
			for i in `seq 0 $Row`;do
				tput cup "$i" 0
				echo -ne "\e[K"
			done
			tput cup 0 0
			echo -ne "\033[0;$Titlecolor $line \033[0m"
			((N=1))
		fi
	else
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		echo "$line"
	fi
}

DISPLAY() {
	#显示歌词函数

	#参数两个，$1： 时间、$2： 字符串；正确执行将字符串格式化输出

	local line tmp

	if [ "$1" ] && [ "$2" ];then
		[ "$Debug" = 1 ]&& echo "DISPLAY: x$1x" >&2
		#下面这一长句之所以这么繁复是为了让歌词文件里面本来是几行，但是因为某种原因合并到一行的烂文件还能正确显示
		#例如：[02:19.46][00:59.86]XXXXXX[03:26.38][02:27.68][01:08.23]YYYYYY
		#亦即即使你把歌曲文件连成只有一行也能正确显示而不会掉词。
		[ "$Tm" != "$1" ] && Tm="$1" && { #只显示与上次时间不一样的
		tmp="`echo "$2"|grep -F "$1."`" && [ "$tmp" ] && { #找到该行
		DIS_WORDS W "`echo "$tmp"|awk -F"$1" \
		'{gsub(/(\[[0-9]*:[0-9]*\.[0-9]*\])|(\.[0-9]*\])/,"\n",$2);print $2}' \
		| grep -v '^$' | head -n 1`"
	} }
	fi
}

GET_STAT() {
	#获取播放器的当前状态

	#没有参数，有两个独立的时间循环，一个用于产生时间信号（独立于播放器的时间信号，一定循环次数以后与播放器的时间相校准，
	#这样减少了获取播放器时间的次数，减少 cpu 开支，但是在有拖动时可能反应有一点延迟）；另一个用于间隔一定时间后获取标题
	#Every line is made up of two parts: 
	#  Title This Song is Great
	#  Time 01:23
	#  Error 播放器已停止或未开启
	#返回的时间为秒
	local pltm0 pltm1 n0 n1 title

	Sleeptm=${Sleeptm:-0.6}

	while :;do
		((n0=${n0:-0}+1)); [ "$n0" -gt 5 ] && n0=1
		((n1=${n1:-0}+1)); [ "$n1" -gt 6 ] && n1=1
		sleep $Sleeptm
		[ "$n0" = "1" ] && [ ! "`pgrep -x $Player`" ] && echo "Error 未发现被支持的播放器进程！" && exit
		[ "$n0" = "1" ] && { 
			pltm0="`GET_PLTM $Player`"
			if [ "${pltm0:-0}" = "$pltm1" ] || [ "$pltm0" = "" ];then
				echo "Error 播放器已停止或未开启！"
				sleep 3
				continue
			else
				pltm1="$pltm0"
			fi 
		}
		[ "$n1" = "1" ] && echo -n "Title " && GET_TITLE $Player $Readname
		echo "Time $(echo "${pltm0:-0}+$Sleeptm*$n0"|bc -l)"
	done
}

HANDLE_PARAM() {
	#读取并处理命令行参数

	#参数 $@ 从命令行传入。

	local param arg title
	while getopts hvC:d:s:p:m:onfcteD param ; do
		case "$param" in
			h|--help)USAGE;exit 0;;
			v|--version)echo $0" Version:"$Version;exit 0;;
			C|--config) Conf_file="$OPTARG";INIT;;
			d|--download)
				title="$OPTARG"
				if [ "$title" ];then
					DOWNLRC "$title"
					if [ -f "$Save_dir/$title.lrc" ];then
						echo "歌词文件 $Save_dir/$title.lrc 已保存。"
					else
						echo "歌词文件下载失败：（"
					fi
				else
					echo "未输入歌曲名！"
				fi
				exit 0;;
			s|--save-dir) Lrcdir="$OPTARG";;
			p|--player) Player="$OPTARG";;
			m|--mode) Dismode="$OPTARG";;
			o|--osd) Dismode=osd;;
			n|-notify) Dismode=notify;;
			f|--fifo) Dismode=fifo;;
			c|--cli) Dismode=cli;;
			t|--title) Dismode=title;;
			e|--echo) Dismode=echo;;
			D|--debug) Debug=1;;
			#-*)gettext "No such option: ">&2; echo "$param"; exit 1;;
			"")
			  gettext "Parameter not used: " 1>&2
			  echo "$arg" 1>&2
			  ;;
		  esac
	done
	shift $((OPTIND-1))

	[ "$Dismode" = "fifo" ] && { [ -p /dev/shm/lrcfifo ] || mkfifo /dev/shm/lrcfifo; }

}

#===========================主流程==============================

INIT
HANDLE_PARAM $@
case "$Dismode" in
	osd|notify|fifo|title|cli|echo)
	sed -i "s/^Dismode=.*/Dismode=$Dismode/" "$Conf_file"
	;;
	*)
	echo "无效的显示模式: $Dismode ,用默认的 echo 模式替代." >&2
	;;
esac
Player="`CHECK_PLAYER`"
if [ "$Player" ];then
	sed -i "s/^Player=.*/Player=$Player/" "$Conf_file"
else
	DIS_WORDS E "未发现被支持的播放器进程！"
	[ "$Dismode" = cli ] && echo
	exit
fi
Title="`GET_TITLE $Player $Readname`"
pltm="`GET_PLTM $Player`"

GET_STAT |while read line0;do
	[ "$Debug" = 1 ] && echo "GET_STAT: $line0<<" >&2
	[ "$line0" = "$line1" ] && continue
	line1="$line0"
	read op arg <<< "$line0"
	[ "$op" = "Error" ] && DIS_WORDS E "$arg"
	[ "$op" = "Title" ] && [ "$title" != "$arg" ] && [ "$arg" != "" ] && {
		title="$arg"
		Title="$arg"
		DIS_WORDS T "$Title";
		if [ -f "$Lrcdir/$Title.lrc" ] ;then
			lrc="$(< "$Lrcdir/$Title.lrc")"
		else
			DOWNLRC "$Title"
			if [ -f "$Lrcdir/$Title.lrc" ] ;then
				lrc="$(< "$Lrcdir/$Title.lrc")"
			else
				lrc=""
				DIS_WORDS E "未能下载歌词"
			fi
		fi
		#处理 offset
		offset="`echo $lrc|awk -F"offset:" '{gsub("].*$","",$2);print $2/1000}'`";offset=${offset:-0}
	}

	[ "$op" = "Time" ] && [ "$lrc" ] && {
		arg="${arg:-0}";
		arg="`bc -l <<< "$arg+$offset" `"
		arg=${arg//.*/};arg=${arg:-0}
		arg="`printf '%.2d:%.2d' $(($arg/60)) $(($arg%60))`"
 		DISPLAY "$arg" "$lrc"
	}
done
