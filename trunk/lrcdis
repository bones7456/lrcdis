#!/bin/bash
# Name:	 lrcdis （外挂式显歌词脚本）
# License:  GPLv3
# Credit:   xiooli,solcomo,bones7456,oldherl  (2008-2009)
# Encoding: UTF-8
# Thanks to: 搜狗歌词搜索

Version=svn-090313
#是否开启调试信息
Debug=0
Conf_file=~/.config/lrcdis.conf

#=========================定义函数=============================

INIT() {	#程序初始化函数

	#没有参数，正确执行如果没有配置文件则会产生配置文件并加载配置，有配置文件则加载配置文件

	[ -f "$Conf_file" ] || cat<< EOF > "$Conf_file"
#===================LRCDIS-CONFIG================
#保存lrc文件的文件夹
Lrcdir=~/.lyrics
#显示模式： cli, osd, notify, fifo (将歌词输出到一个管道文件，以便用其他命令访问)
Dismode=osd
#播放器类型： mpd, mocp, audacious, amarok, exaile, quodlibet, rhythmbox
Player=rhythmbox
#获取歌曲名称方式： id3 id3标签方式， filename 文件名方式
Readname=id3
#自身时间发生器产生时间的间隔（最好小于1秒）
Sleeptm=0.6
#======================[cli]=====================
#命令行显示时的参数
#一屏显示行数
Row=10
#歌曲标题的颜色（见最后的颜色定义）
Titlecolor=\$green
#歌曲歌词的颜色（见最后的颜色定义）
Lyricscolor=\$smoothblue
#=================[osd && notify]================
#osd显示时的参数
#osd显示位置：top, bottom
Vposition=top
#osd对齐位置：left, right, center
Halignment=center
#osd最长显示时间（超过则隐藏,单位毫秒？）
Timeout=10000
#span size
Size=20000
#字体颜色： green, white, blue, yellow, grey...
#注意，这个颜色与cli模式的颜色不是一回事
Foreground=green
#动画效果： off, on
Animations=off
#是否加新行，以免挡住panel等: off, on
Addnewline=off
#notify模式的图标文件名(只支持绝对路径)
NotifyIcon=""
#================================================
#定义颜色（仅在cli模式下使用）
black="38;5;0m"
red="38;5;1m"
green="38;5;2m"
yellow="38;5;3m"
blue="38;5;4m"
magenta="38;5;55m"
cyan="38;5;6m"
white="37;5;0m"
coldblue="38;5;33m"
smoothblue="38;5;111m"
iceblue="38;5;45m"
turqoise="38;5;50m"
smoothgreen="38;5;42m"
#======================END========================
EOF

	. "$Conf_file" #在这里如果source一次的话颜色代码不会工作，大家看看怎么改。（source两次太恶了）-- xiooli
	[ ! -d "$Lrcdir" ] && mkdir -p "$Lrcdir"
	. "$Conf_file"
}

DO_NAME() {
	#  1 argument, the filename
	#  removing .mp3/.wma/.ogg etc.
	local a
	a="`basename "$1"`"
	a="${a/%.mp3/}"; a="${a/%.MP3/}"
	a="${a/%.wma/}"; a="${a/%.WMA/}"
	a="${a/%.ogg/}"; a="${a/%.OGG/}"
	echo "$a"
}

USAGE() {   #显示帮助信息的函数

	#没有参数，执行显示帮助信息

	cat << EOF
用法： $0 [选项] [参数]
选项：
	-d, --download <歌曲名>
		仅下载歌词, 保存至默认目录 ${Lrcdir:-~/.lyrics}
	-C, --config <config file name>
		specify config file name (default: ~/.config/lrcdis.conf)
	-m, --mode <Dismode>
		Display in that mode. (osd, cli, notify, fifo, title, echo)
	-o, --osd
		自动检查播放器并以osd模式显示歌词
	-n, --notify
		自动检查播放器并以notify模式显示歌词
	-f, --fifo
		自动检查播放器并将歌词输出到管道文件/dev/shm/lrcfifo
	-t, --title
		自动检查播放器并将歌词输出到gnome-terminal之类标题中
	-e, --echo
		自动检查播放器并将歌词以普通echo模式输出
	-c, --cli
		自动检查播放器并以cli模式显示歌词
	-D, --debug
		Debug mode
	-h, --help
		显示本帮助信息并退出
	-v, --version
		显示版本号并退出
	备注：不加任何参数则以 $Conf_file 为配置文件初始化运行
EOF
}

CHECK_PLAYER() {	#自动检查播放器类型的函数
	
	#没有参数，返回播放器类型
	
	local players i

	#所有被支持的播放器都保存下面的字符串里面
	players="rhythmbox audacious amarok amarokapp exaile quodli quodlibet mocp mpd mplayer"
	if pgrep -f "$Player" >/dev/null;then
		echo -n "$Player"
	else
		for i in $players;do
			[ "$Debug" = 1 ] && echo "$Player   $i" >&2
			if pgrep -f "$i" >/dev/null ;then
				echo -n "$i"|sed "s/quodli/quodlibet/;s/amarokapp/amarok/"
				break
			fi
		done
	fi
}

BAIDU_URI(){
	# 1 argument: gb
	local htm
	htm="`wget "http://mp3.baidu.com/m?f=ms&tn=baidump3lyric&ct=150994944&lf=2&rn=10&word="$1"&lm=-1" -q -T 10 -O- 2>/dev/null`"
	echo "$htm" | grep -F .lrc | cut -d' ' -f3 | cut '-d"' -f2 | head -n 1
}
SOGOU_URI(){
	# 1 argument: gb
	local htm a
	htm="`wget "http://mp3.sogou.com/gecisearch.so?query="$1"" -q -T 10 -O- 2>/dev/null | iconv -f gbk`"
	#[ "$Debug" = 1 ] && echo "HTM $htm" > /tmp/htm
	a="`echo "$htm" | grep -Fim1 "downlrc"|awk -F\\\" '{print $2}'`"
	[ "$Debug" = 1 ] && echo "A $a" >&2
	[ "$a" = "" ]|| echo -n 'http://mp3.sogou.com/'"$a"
}

DOWNLRC(){	  #下载歌词的函数

	#参数一个，$1 (str)： 歌曲名字; 没有返回值，正确执行会下载一个 lrc 文件至 Lrcdir

	local nm link full_link gb

	nm="$1"
	Save_dir="${2:-$Lrcdir}"
	Save_dir="${Save_dir/%\//}"

	#将歌曲名字转换为urlencode，utf-8的locale必须先转换为gbk的编码
  	gb="$(echo -n "$nm" | iconv -c -t gbk | od -t x1 -A n -w1000|tr " " "%")"

	#从baidu搜索里面找出当前歌曲的歌词下载页
	#FIXME: just for a try
  	link="`SOGOU_URI "$gb"`"
	[ "$Debug" = 1 ] && echo "Link: $link" >&2
  	while [ "$link" ] && [ ! -s "$Save_dir/$nm.lrc" ];do
		wget "$link" -T 5 -t 2 -q -O -|iconv -f gbk -c | tr -d "\r" > "$Save_dir/$nm.lrc"
		{ echo '<xml>'; cat "$Save_dir/$nm.lrc"; echo '</xml>';} > /tmp/lrcdisTMP.xml
		xmllint /tmp/lrcdisTMP.xml --encode UTF-8 2>/dev/null > /tmp/lrcdisTMP.lrc && {
			cat /tmp/lrcdisTMP.lrc | head -n -1 | tail -n +3 > "$Save_dir/$nm.lrc"
		}
		rm /tmp/lrcdisTMP* &>/dev/null
	done
}

GET_TITLE() {	   #获取当前播放的歌曲名字

	#参数两个，$1 播放器类型,默认 rhythmbox、$2 获取歌曲名字方式，默认取id3; 返回正在播放的歌曲名

	local readname t a tmp flag ans sn

	readname=${2:-id3}

	case "${1:-rhythmbox}" in
	"mpd")
	flag="LRCDISXXX"
	if [ "$readname" = "filename" ] ; then
		  sn="`mpc --format "$flag%file%" | grep "$flag" `"
		  ans="${sn/$flag/}"
	else  
		  sn="`mpc --format "[$flag[%artist% - ]%title%]|$flag[%file%]" | grep "$flag" `"
		  ans="${sn/$flag/}"
	fi  
	ans="`DO_NAME "$ans"`"
	echo "$ans"
	[ "$Debug" = 1 ]&& echo "GET_TITLE: $ans" >&2
	;;
	"mocp")
		if [ "$readname" = "filename" ];then
			mocp -i|grep -i "^File"|sed "s/.*\///g"|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$0);print $0 }'
		else
			t="`mocp -i|grep "^SongTitle:"|sed "s/.*:\ //"`"
			a="`mocp -i|grep "^Artist:"|sed "s/.*:\ //"`"
			if [ "$t" -a "$a" ];then
				echo "$a" - "$t"
			else
				mocp -i|grep -i "^File"|sed "s/.*\///g"|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$0);print $0 }'
			fi
		fi
	;;
	"audacious")
		if [ "$readname" = "filename" ];then
			f="`audtool current-song-filename`"
			echo "`DO_NAME "$f"`"
		else
			t="`audtool current-song`"
			if [ "$t" ];then
				echo "$t"
			else
				f="`audtool current-song-filename`"
				echo "`DO_NAME "$f"`"
			fi
		fi
	;;
	"amarok")
		if [ "`amarok -v|grep "Amarok:\ *2\.*"`" ];then
			t="`qdbus org.kde.amarok /Player GetMetadata|grep "^title:"|sed "s/title: *//"`"
			a="`qdbus org.kde.amarok /Player GetMetadata|grep "^artist:"|sed "s/artist: *//"`"
		if [ "$t" -a "$a" ];then
			echo "$a" - "$t"
		else
			echo "$t"
		fi
		else
			dcop amarok player nowPlaying|sed "s/.*\///g"|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$0);print $0 }'
		fi
	;;
	"exaile")
		t="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.get_title \
			| sed -n '$p'|awk -F'"' '{print $2}'`"
		tmp="`echo "$t"|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$0);print $0 }'`"
		if [ "$tmp" != "$t" ] ; then
			echo "$tmp"
		else
			a="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.get_artist \
			| sed -n '$p'|awk -F'"' '{print $2}'`"
			echo "$a" - "$t"
		fi
	;;
	"quodlibet")
		sn="`dbus-send --session --print-reply --dest=net.sacredchao.QuodLibet /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.CurrentSong`"
		a="`echo "$sn" | grep -FA1 '   string "artist' | tail -n 1 | awk '-F[\"\"]' '{print $2}'`"
		t="`echo "$sn" | grep -FA1 '   string "title' | tail -n 1 | awk '-F[\"\"]' '{print $2}'`"
		echo "$a" - "$t"
	;;
	"rhythmbox")
		t="`rhythmbox-client --print-playing --no-start|awk '{ gsub(/\.mp3|\.wma|\.MP3|\.WMA|未播放/,"",$0);print $0 }'`"
		[ "$t" ] || exit
		echo "$t"
	;;
	"mplayer")
		[ -p "/dev/shm/mfifo" -a -p "/dev/shm/ififo" -a "`ps ax|grep "mplayer"|grep "/dev/shm/mfifo"`" ] || exit
		echo "get_file_name">/dev/shm/mfifo
		t="`cat "/dev/shm/ififo"|awk -F"\'" '/^ANS_FILENAME/{gsub(/\.mp3|\.wma|\.MP3|\.WMA/,"",$2);print $2}'`"
		[ "$t" ] && echo "$t"
	;;
	esac
}   

GET_PLTM() {
	
   #参数一个，$1，播放器类型；返回播放器播放歌曲的当前时间 (转换成秒)
   #GET_PLTM如果是空那么就表示已经停止或者播放器退出。
   
	local tm min sec tmptm

	case "${1:-rhythmbox}" in
	"mpd")
		tm="`mpc --format a | grep "/" | awk -F' ' '{print $3}' | awk -F'/' '{print $1}'`"
		[ "$Debug" = 1 ] && echo "GET_PLTM: ${tm}<<" >&2
		[ -n "$tm" ] && {
			min=${tm//:*/}
			tmptm=${tm//*:/}
			sec=${tmptm/#0/}
			echo "$(($min*60+$sec))"
		}
	;;
	"mocp")
		tm="`mocp -i | grep "CurrentTime" | sed -e 's/CurrentTime:\ //'`"
		min=${tm//:*/}
		tmptm=${tm//*:/}
		sec=${tmptm/#0/}
		[ "$tm" ] && echo $(($min*60+$sec))
	;;
	"audacious")
		tm="`audtool current-song-output-length-seconds`"
		[ "$tm" ] && echo "$tm"
	;;
	"amarok")
		if [ "`amarok -v|grep "Amarok:\ *2\.*"`" ];then
			tm="`qdbus org.kde.amarok /Player PositionGet`"
			tm=$(($tm/1000))
		else
			tm="`dcop amarok player trackCurrentTime`"
		fi
			[ "$tm" ] && echo "$tm"
	;;
	"exaile")
		tm="`dbus-send --session --print-reply --dest=org.exaile.DBusInterface /DBusInterfaceObject org.exaile.DBusInterface.query \
		| sed -n '$p'|awk -F[][] '{print $2}'`"
		min=${tm//:*/}
		tmptm=${tm//*:/}
		sec=${tmptm/#0/}
		[ "$tm" ] && echo $(($min*60+$sec))
	;;
	"quodlibet")
		tm="`dbus-send --session --print-reply --dest=net.sacredchao.QuodLibet /net/sacredchao/QuodLibet net.sacredchao.QuodLibet.GetPosition| \
		sed -n '$p'|awk '{print $2}'`"
		[ "$tm" ] && echo $(($tm/1000))
	;;
	"rhythmbox")
		tm="`qdbus org.gnome.Rhythmbox /org/gnome/Rhythmbox/Player org.gnome.Rhythmbox.Player.getElapsed`"
		[ "$tm" ] && echo "$tm"
	;;
	"mplayer")
		[ -p "/dev/shm/mfifo" -a -p "/dev/shm/ififo" -a "`ps ax|grep "mplayer"|grep "/dev/shm/mfifo"`" ] || exit
		echo "get_time_pos">/dev/shm/mfifo
		tm="`cat "/dev/shm/ififo"|sed 's/^.*=//;s/\..*$//'`"
		[ "${tm//-/}" = "$tm" -a "$tm" != "0" ] && echo "$tm"
	;;
	esac

}

DIS_WORDS() {		#以各种预设的模式显示文字

	#两个参数; $1:T标题W普通歌词E错误信息  正确执行按照Dismode将 $2 格式化输出

	local line i j nl

	line="$2"
	nl="\n "
	#[ "$2" = "" ] && exit

	if [ "$Dismode" = "osd" -a "`which gnome-osd-client 2>/dev/null`" ];then
		line="`echo "$line" | sed "s/&/\&amp;/g" | sed "s/</\&lt;/g" | sed "s/>/\&gt;/g"`"
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		if [ "$Addnewline" = "on" ];then
			if [ "$Vposition" = "top" ];then
				line="$nl$line"
			else
				line="$line$nl"
			fi
		fi
		#NOTE: 下面的echo是需要的，不然\n会直接显示出来。
		gnome-osd-client -f "<message id='lrcdis' osd_fake_translucent_bg='off' osd_vposition='$Vposition' osd_halignment='$Halignment' animations='$Animations' hide_timeout='$Timeout'><span size='$Size' foreground='$Foreground'>`echo -ne "$line"`</span></message>"
	elif [ "$Dismode" = "fifo" -a -p "/dev/shm/lrcfifo" ];then
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		#cat < /dev/shm/lrcfifo & # there's no need to empty the fifo file anymore.
		echo -ne "$line" > /dev/shm/lrcfifo
	elif [ "$Dismode" = "notify" -a "`which notify-send 2>/dev/null`" ];then
		[ "$2" = "" ] && return
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		if [ -n "$NotifyIcon" ];then
			notify-send -c lrcdis -i "$NotifyIcon" -t "$Timeout" -- "$line"
		else
			notify-send -c lrcdis -t "$Timeout" -- "$line"
		fi
	elif [ "$Dismode" = "title" ];then
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		echo -ne "\e]0;$line\a"
	elif [ "$Dismode" = "echo" ];then
		[ "$1" = T ] && line="****** $line ******"
		[ "$1" = E ] && line="错误: $line"
		echo "$line"
	else
		if [ "$1" = W ] ;then
			N="${N:-1}"
			[ "$N" = "1" ] && \
			for i in `seq $Row`;do
				tput cup "$i" 0
				echo -ne "\e[K"
			done
			tput cup "$N" 0
			echo -ne "\033[0;$Lyricscolor "${line/#]/}" \033[0m"
			if [ "$N" -lt "$Row" ];then
				((N="$N"+1))
			else
				((N=1))
			fi
		else
			if [ "$1" = T ] ;then
				line="****** $line ******"
			else
				line="错误: $line"
			fi
			for i in `seq 0 $Row`;do
				tput cup "$i" 0
				echo -ne "\e[K"
			done
			tput cup 0 0
			echo -ne "\033[0;$Titlecolor $line \033[0m"
			((N=1))
		fi
	fi
}

DISPLAY() {		 #显示歌词函数

	#参数两个，$1： 时间、$2： 字符串；正确执行将字符串格式化输出

	local line tmp

	if [ "$1" ] && [ "$2" ];then
		[ "$Debug" = 1 ]&& echo "DISPLAY: x$1x" >&2
		#下面这一长句之所以这么繁复是为了让歌词文件里面本来是几行，但是因为某种原因合并到一行的烂文件还能正确显示
		#例如：[02:19.46][00:59.86]XXXXXX[03:26.38][02:27.68][01:08.23]YYYYYY
		#亦即即使你把歌曲文件连成只有一行也能正确显示而不会掉词。
		[ "$Tm" != "$1" ] && Tm="$1" && { #只显示与上次时间不一样的
		tmp="`echo "$2"|grep -F "$1."`" && [ "$tmp" ] && { #找到该行
		DIS_WORDS W "`echo "$tmp"|awk -F"$1" \
		'{gsub(/(\[[0-9]*:[0-9]*\.[0-9]*\])|(\.[0-9]*\])/,"\n",$2);print $2}' \
		| grep -v '^$' | head -n 1`"
	} }
	fi
}

GET_STAT() {	#获取播放器的当前状态

	#没有参数，有两个独立的时间循环，一个用于产生时间信号（独立于播放器的时间信号，一定循环次数以后与播放器的时间相校准，
	#这样减少了获取播放器时间的次数，减少 cpu 开支，但是在有拖动时可能反应有一点延迟）；另一个用于间隔一定时间后获取标题
	#Every line is made up of two parts: 
	#  Title This Song is Great
	#  Time 01:23
	#  Error 播放器已停止或未开启
	#返回的时间为秒
	local pltm0 pltm1 n0 n1 title

	Sleeptm=${Sleeptm:-0.6}

	while :;do			
		((n0=${n0:-0}+1)); [ "$n0" -gt 5 ] && n0=1
		((n1=${n1:-0}+1)); [ "$n1" -gt 6 ] && n1=1
		sleep $Sleeptm
		[ "$n0" = "1" ] && [ ! "`pgrep -f $Player`" ] && echo "Error 未发现被支持的播放器进程！" && exit
		[ "$n0" = "1" ] && { 
			pltm0="`GET_PLTM $Player`"
			if [ "${pltm0:-0}" = "$pltm1" ] || [ "$pltm0" = "" ];then
				echo "Error 播放器已停止或未开启！"
				sleep 3
				continue
			else
				pltm1="$pltm0"
			fi 
		}
		[ "$n1" = "1" ] && echo -n "Title " && GET_TITLE $Player $Readname
		echo "Time $(echo "${pltm0:-0}+$Sleeptm*$n0"|bc -l)"
	done
}

#===========================主流程==============================

HANDLE_PARAM() { 	#读取并处理命令行参数

	#参数 $@ 从命令行传入。

	local param arg title
	while getopts onfctm:eC:vp:hd:D param ; do
		case "$param" in
			h|--help)USAGE;exit 0;;
			v|--version)echo $0" Version:"$Version;exit 0;;
			C|--config) Conf_file="$OPTARG";INIT;;
			d|--download)
				title="$OPTARG"
				if [ "$title" ];then
					DOWNLRC "$title"
					if [ -f "$Save_dir/$title.lrc" ];then
						echo "歌词文件 $Save_dir/$title.lrc 已保存。"
					else
						echo "歌词文件下载失败：（"
					fi
				else
					echo "未输入歌曲名！"
				fi
				exit 0;;
			s|--save-dir) Save_dir="$OPTARG";;
			p|--player) Player="$OPTARG";;
			m|--mode) Dismode="$OPTARG";;
			o|--osd) Dismode=osd;;
			n|-notify) Dismode=notify;;
			f|--fifo) Dismode=fifo;;
			c|--cli) Dismode=cli;;
			t|--title) Dismode=title;;
			e|--echo) Dismode=echo;;
			D|--debug) Debug=1;;
			#-*)gettext "No such option: ">&2; echo "$param"; exit 1;;
			"")
			  gettext "Parameter not used: " 1>&2
			  echo "$arg" 1>&2
			  ;;
		  esac
	done
	shift $((OPTIND-1))

	[ "$Dismode" = "fifo" ] && { [ -p /dev/shm/lrcfifo ] || mkfifo /dev/shm/lrcfifo; }

}

INIT
HANDLE_PARAM $@
sed -i "s/^Dismode=.*/Dismode=$Dismode/" "$Conf_file"
Player="`CHECK_PLAYER`"
if [ "$Player" ];then
	sed -i "s/^Player=.*/Player=$Player/" "$Conf_file"
else
	DIS_WORDS E "未发现被支持的播放器进程！"
	[ "$Dismode" = cli ] && echo
	exit
fi
Title="`GET_TITLE $Player $Readname`"
pltm="`GET_PLTM $Player`"

GET_STAT |while read line0;do
	[ "$Debug" = 1 ] && echo "GET_STAT: $line0<<" >&2
	[ "$line0" = "$line1" ] && continue
	line1="$line0"
	read op arg <<< "$line0"
	[ "$op" = "Error" ] && DIS_WORDS E "$arg"
	[ "$op" = "Title" ] && [ "$title" != "$arg" ] && [ "$arg" != "" ] && {
		title="$arg"
		Title="$arg"
		DIS_WORDS T "$Title";
		if [ -f "$Lrcdir/$Title.lrc" ] ;then
			lrc="$(< "$Lrcdir/$Title.lrc")"
		else
			DOWNLRC "$Title"
			if [ -f "$Lrcdir/$Title.lrc" ] ;then
				lrc="$(< "$Lrcdir/$Title.lrc")"
			else
				lrc=""
				DIS_WORDS E "未能下载歌词"
			fi
		fi
		#处理 offset
		offset="`echo $lrc|awk -F"offset:" '{gsub("].*$","",$2);print $2/1000}'`";offset=${offset:-0}
	}

	[ "$op" = "Time" ] && [ "$lrc" ] && {
		arg="$(echo "${arg:-0}+$offset"|bc -l)";arg=${arg//.*/};arg=${arg:-0}
		arg="`printf '%.2d:%.2d\n' $(($arg/60)) $(($arg%60))`"
 		DISPLAY "$arg" "$lrc"
	}
done
